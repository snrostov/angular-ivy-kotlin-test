import * as ng from "@angular/compiler-cli";
import {CompilerHost} from "@angular/compiler-cli";
import * as ts from "typescript";
import {EmitHint} from "typescript";
import {readCommandLineAndConfiguration} from "@angular/compiler-cli/src/main";
import {
    ComponentDecoratorHandler,
    DirectiveDecoratorHandler,
    InjectableDecoratorHandler,
    NgModuleDecoratorHandler,
    SelectorScopeRegistry
} from "@angular/compiler-cli/src/ngtsc/annotations";
import {TypeScriptReflectionHost} from "@angular/compiler-cli/src/ngtsc/metadata";
import {IvyCompilation} from "@angular/compiler-cli/src/ngtsc/transform";
import {
    ImportManager,
    translateExpression,
    translateStatement
} from "@angular/compiler-cli/src/ngtsc/transform/src/translator";
import * as path from "path";
import {Import} from "@angular/compiler-cli/src/ngtsc/host/src/reflection";

// CLI entry point
if (require.main === module) {
    const args = process.argv.slice(2);
    process.exitCode = ngktc(args);
}

export function ngktc(args: string[]) {
    let {project, rootNames, options, errors: configErrors, emitFlags} = readCommandLineAndConfiguration(args);

    options.enableIvy = 'ngtsc';

    let host = ng.createCompilerHost({options});
    const program = ng.createProgram({rootNames, host, options});

    const emitResult = emit((program as any)['tsProgram'], host, options);

    return reportErrorsAndExit(emitResult.diagnostics);
}

function emit(
    tsProg: ts.Program,
    host: ng.CompilerHost,
    compilerOpts: ng.CompilerOptions,
    opts?: {
        emitFlags?: ng.EmitFlags,
        cancellationToken?: ts.CancellationToken,
        customTransformers?: ng.CustomTransformers,
        emitCallback?: ng.TsEmitCallback,
        mergeEmitResultsCallback?: ng.TsMergeEmitResultsCallback
    }
): ts.EmitResult {
    const checker = tsProg.getTypeChecker();
    const reflector = new TypeScriptReflectionHost(checker);
    const scopeRegistry = new SelectorScopeRegistry(checker, reflector);

    // Set up the IvyCompilation, which manages state for the Ivy transformer.
    const handlers = [
        new ComponentDecoratorHandler(checker, reflector, scopeRegistry),
        new DirectiveDecoratorHandler(checker, reflector, scopeRegistry),
        new InjectableDecoratorHandler(reflector),
        new NgModuleDecoratorHandler(checker, scopeRegistry),
    ];

    const compilation = new IvyCompilation(handlers, checker, reflector);
    let allDiagnostics: Array<ts.Diagnostic> = [];

    // Analyze every source file in the program.
    tsProg.getSourceFiles()
        .forEach(file => {
            allDiagnostics = allDiagnostics.concat(compilation.analyze(file));
        });

    const printer = ts.createPrinter();
    const emittedFiles: Array<string> = [];

    tsProg.getSourceFiles().forEach(file => {
        if (file.fileName.endsWith('.d.d.ts')) {
            const importManager = new ImportManager();
            const contents: Array<string> = [];

            let wasCompiled = false;

            const dTsDecoratorsToFilter: Array<{
                /**
                 * `Import` by which the decorator was brought into the module in which it was invoked, or `null`
                 * if the decorator was declared in the same module and not imported.
                 */
                import: Import | null;
                /**
                 * TypeScript reference to the decorator itself.
                 */
                node: ts.Node;
            }> = [];

            ts.forEachChild(file, node => {
                if (ts.isClassDeclaration(node)) {
                    const field = compilation.compileIvyFieldFor(node);
                    if (field !== undefined && node.name) {
                        const decorator = compilation.ivyDecoratorFor(node);
                        if (decorator) dTsDecoratorsToFilter.push(decorator);

                        wasCompiled = true;
                        const className = node.name.escapedText;

                        const expr = translateExpression(field.initializer, importManager);
                        const statements = field.statements.map(stmt => printer.printNode(
                            EmitHint.Unspecified,
                            translateStatement(stmt, importManager),
                            file
                        ));

                        const exprString = printer.printNode(EmitHint.Expression, expr, file);
                        contents.push(
                            `// BEGIN class generated by kotlin compiler \n` +
                            `export const ${className} = /* @constructor */ function() {};\n` +
                            `// END class generated by kotlin compiler \n` +
                            `\n` +
                            `${className}.${field.field} = ${exprString};` +
                            `\n` +
                            `${statements.join(';\n')}`
                        );
                    }
                }
            });

            if (wasCompiled) {
                // Generate the import statements to prepend.
                const imports = importManager.getAllImports().map(
                    i => printer.printNode(
                        EmitHint.Unspecified,
                        ts.createImportDeclaration(
                            undefined, undefined,
                            ts.createImportClause(undefined, ts.createNamespaceImport(ts.createIdentifier(i.as))),
                            ts.createLiteral(i.name)
                        ),
                        file
                    )
                );

                const fileBaseName = path.parse(file.fileName).base;
                const originalFileName = fileBaseName.substr(0, fileBaseName.length - '.d.d.ts'.length);
                const outputFileName = `${compilerOpts.outDir}/${originalFileName}.js`;
                emittedFiles.push(outputFileName);

                host.writeFile(
                    outputFileName,
                    imports.concat([''], contents).join('\n'),
                    false,
                    undefined,
                    [file]
                );

                const outputDTsFileName = `${compilerOpts.outDir}/${originalFileName}.d.ts`;
                emittedFiles.push(outputDTsFileName);

                // emitCleanedAndTransformedDts({
                //     dTsDecoratorsToFilter: dTsDecoratorsToFilter,
                //     file: file,
                //     compilation: compilation,
                //     host: host,
                //     outputDTsFileName: outputDTsFileName
                // });

                const clean_dts = host.readFile(file.fileName.replace(".d.d", ".d"));
                let dTsContents = compilation.transformedDtsFor(file.fileName, clean_dts!);

                host.writeFile(
                    outputDTsFileName,
                    dTsContents,
                    false,
                    undefined,
                    [file]
                );
            }
        }
    });

    return {
        emitSkipped: false,
        emittedFiles: emittedFiles,
        diagnostics: allDiagnostics
    };
}

function emitCleanedAndTransformedDts(parameters: {
    dTsDecoratorsToFilter: Array<{ import: Import | null; node: ts.Node }>,
    file: ts.SourceFile,
    compilation: IvyCompilation,
    host: CompilerHost,
    outputDTsFileName: string
}) {
    let {dTsDecoratorsToFilter, file, compilation, host, outputDTsFileName} = parameters;

// collect string before transforming (or offsets will be invalid)
    // todo: find proper way to remove decorators
    const strsToRemove: Array<string> = [];
    dTsDecoratorsToFilter.forEach(item => {
        let it = item.import;
        if (it) {
            // todo: support more cases, for example `import {A, B} from "C"`
            strsToRemove.push(`import {${it.name}} from "${it.from}";`, '');
        }

        strsToRemove.push(item.node.getFullText(file));
    });

    let dTsContents = compilation.transformedDtsFor(file.fileName, file.text);
    strsToRemove.forEach(item => {
        dTsContents = dTsContents.replace(item, '');
    });

    host.writeFile(
        outputDTsFileName,
        dTsContents,
        false,
        undefined,
        [file]
    );
}

function reportErrorsAndExit(allDiagnostics: ng.Diagnostics): number {
    const errorsAndWarnings = ng.filterErrorsAndWarnings(allDiagnostics);
    if (errorsAndWarnings.length) {
        const formatHost: ts.FormatDiagnosticsHost = {
            getCurrentDirectory: () => ts.sys.getCurrentDirectory(),
            getCanonicalFileName: fileName => fileName,
            getNewLine: () => ts.sys.newLine
        };
        console.error(ng.formatDiagnostics(errorsAndWarnings, formatHost));
    }
    return ng.exitCodeFromResult(allDiagnostics);
}
