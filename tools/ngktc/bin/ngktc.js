"use strict";
exports.__esModule = true;
var ng = require("@angular/compiler-cli");
var ts = require("typescript");
var typescript_1 = require("typescript");
var main_1 = require("@angular/compiler-cli/src/main");
var annotations_1 = require("@angular/compiler-cli/src/ngtsc/annotations");
var metadata_1 = require("@angular/compiler-cli/src/ngtsc/metadata");
var transform_1 = require("@angular/compiler-cli/src/ngtsc/transform");
var translator_1 = require("@angular/compiler-cli/src/ngtsc/transform/src/translator");
var path = require("path");
// CLI entry point
if (require.main === module) {
    var args = process.argv.slice(2);
    process.exitCode = ngktc(args);
}
function ngktc(args) {
    var _a = main_1.readCommandLineAndConfiguration(args), project = _a.project, rootNames = _a.rootNames, options = _a.options, configErrors = _a.errors, emitFlags = _a.emitFlags;
    options.enableIvy = 'ngtsc';
    var host = ng.createCompilerHost({ options: options });
    var program = ng.createProgram({ rootNames: rootNames, host: host, options: options });
    var emitResult = emit(program['tsProgram'], host, options);
    return reportErrorsAndExit(emitResult.diagnostics);
}
exports.ngktc = ngktc;
function emit(tsProg, host, compilerOpts, opts) {
    var checker = tsProg.getTypeChecker();
    var reflector = new metadata_1.TypeScriptReflectionHost(checker);
    var scopeRegistry = new annotations_1.SelectorScopeRegistry(checker, reflector);
    // Set up the IvyCompilation, which manages state for the Ivy transformer.
    var handlers = [
        new annotations_1.ComponentDecoratorHandler(checker, reflector, scopeRegistry),
        new annotations_1.DirectiveDecoratorHandler(checker, reflector, scopeRegistry),
        new annotations_1.InjectableDecoratorHandler(reflector),
        new annotations_1.NgModuleDecoratorHandler(checker, scopeRegistry),
    ];
    var compilation = new transform_1.IvyCompilation(handlers, checker, reflector);
    var allDiagnostics = [];
    // Analyze every source file in the program.
    tsProg.getSourceFiles()
        .forEach(function (file) {
        allDiagnostics = allDiagnostics.concat(compilation.analyze(file));
    });
    var printer = ts.createPrinter();
    var emittedFiles = [];
    tsProg.getSourceFiles().forEach(function (file) {
        if (file.fileName.endsWith('.d.d.ts')) {
            var importManager_1 = new translator_1.ImportManager();
            var contents_1 = [];
            var wasCompiled_1 = false;
            var dTsDecoratorsToFilter_1 = [];
            ts.forEachChild(file, function (node) {
                if (ts.isClassDeclaration(node)) {
                    var field = compilation.compileIvyFieldFor(node);
                    if (field !== undefined && node.name) {
                        var decorator = compilation.ivyDecoratorFor(node);
                        if (decorator)
                            dTsDecoratorsToFilter_1.push(decorator);
                        wasCompiled_1 = true;
                        var className = node.name.escapedText;
                        var expr = translator_1.translateExpression(field.initializer, importManager_1);
                        var statements = field.statements.map(function (stmt) { return printer.printNode(typescript_1.EmitHint.Unspecified, translator_1.translateStatement(stmt, importManager_1), file); });
                        var exprString = printer.printNode(typescript_1.EmitHint.Expression, expr, file);
                        contents_1.push("// BEGIN class generated by kotlin compiler \n" +
                            ("export const " + className + " = /* @constructor */ function() {};\n") +
                            "// END class generated by kotlin compiler \n" +
                            "\n" +
                            (className + "." + field.field + " = " + exprString + ";") +
                            "\n" +
                            ("" + statements.join(';\n')));
                    }
                }
            });
            if (wasCompiled_1) {
                // Generate the import statements to prepend.
                var imports = importManager_1.getAllImports().map(function (i) { return printer.printNode(typescript_1.EmitHint.Unspecified, ts.createImportDeclaration(undefined, undefined, ts.createImportClause(undefined, ts.createNamespaceImport(ts.createIdentifier(i.as))), ts.createLiteral(i.name)), file); });
                var fileBaseName = path.parse(file.fileName).base;
                var originalFileName = fileBaseName.substr(0, fileBaseName.length - '.d.d.ts'.length);
                var outputFileName = compilerOpts.outDir + "/" + originalFileName + ".js";
                emittedFiles.push(outputFileName);
                host.writeFile(outputFileName, imports.concat([''], contents_1).join('\n'), false, undefined, [file]);
                var outputDTsFileName = compilerOpts.outDir + "/" + originalFileName + ".d.ts";
                emittedFiles.push(outputDTsFileName);
                // emitCleanedAndTransformedDts({
                //     dTsDecoratorsToFilter: dTsDecoratorsToFilter,
                //     file: file,
                //     compilation: compilation,
                //     host: host,
                //     outputDTsFileName: outputDTsFileName
                // });
                var clean_dts = host.readFile(file.fileName.replace(".d.d", ".d"));
                var dTsContents = compilation.transformedDtsFor(file.fileName, clean_dts);
                host.writeFile(outputDTsFileName, dTsContents, false, undefined, [file]);
            }
        }
    });
    return {
        emitSkipped: false,
        emittedFiles: emittedFiles,
        diagnostics: allDiagnostics
    };
}
function emitCleanedAndTransformedDts(parameters) {
    var dTsDecoratorsToFilter = parameters.dTsDecoratorsToFilter, file = parameters.file, compilation = parameters.compilation, host = parameters.host, outputDTsFileName = parameters.outputDTsFileName;
    // collect string before transforming (or offsets will be invalid)
    // todo: find proper way to remove decorators
    var strsToRemove = [];
    dTsDecoratorsToFilter.forEach(function (item) {
        var it = item["import"];
        if (it) {
            // todo: support more cases, for example `import {A, B} from "C"`
            strsToRemove.push("import {" + it.name + "} from \"" + it.from + "\";", '');
        }
        strsToRemove.push(item.node.getFullText(file));
    });
    var dTsContents = compilation.transformedDtsFor(file.fileName, file.text);
    strsToRemove.forEach(function (item) {
        dTsContents = dTsContents.replace(item, '');
    });
    host.writeFile(outputDTsFileName, dTsContents, false, undefined, [file]);
}
function reportErrorsAndExit(allDiagnostics) {
    var errorsAndWarnings = ng.filterErrorsAndWarnings(allDiagnostics);
    if (errorsAndWarnings.length) {
        var formatHost = {
            getCurrentDirectory: function () { return ts.sys.getCurrentDirectory(); },
            getCanonicalFileName: function (fileName) { return fileName; },
            getNewLine: function () { return ts.sys.newLine; }
        };
        console.error(ng.formatDiagnostics(errorsAndWarnings, formatHost));
    }
    return ng.exitCodeFromResult(allDiagnostics);
}
//# sourceMappingURL=ngktc.js.map